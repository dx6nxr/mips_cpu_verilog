$date
	Mon Jun 19 13:55:03 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module SanitizerMain $end
$scope module proc $end
$scope module imem $end
$var reg 32 ! \INSTRROM[0] [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$scope module dmem $end
$var reg 32 " \DATARAM[0] [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$var wire 32 # pc [31:0] $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$var wire 32 $ instr [31:0] $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$var wire 32 % readdata [31:0] $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$var wire 32 & writedata [31:0] $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$var wire 32 ' dataaddr [31:0] $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$var wire 1 ( datawrite $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$scope module mips $end
$var wire 1 ) clk $end
$var wire 32 * instr [31:0] $end
$var wire 32 + readdata [31:0] $end
$var wire 1 , reset $end
$var wire 1 - zero $end
$var wire 32 . writedata [31:0] $end
$var wire 1 / shift16left $end
$var wire 1 0 regwrite $end
$var wire 32 1 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 2 memtoreg $end
$var wire 1 3 dojump $end
$var wire 1 4 dojr $end
$var wire 1 5 dojal $end
$var wire 1 6 dobranch $end
$var wire 5 7 destreg [4:0] $end
$var wire 1 8 alusrcbimm $end
$var wire 32 9 aluout [31:0] $end
$var wire 3 : alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 ; instr [31:0] $end
$var wire 1 - zero $end
$var wire 6 < op [5:0] $end
$var wire 6 = funct [5:0] $end
$var reg 3 > alucontrol [2:0] $end
$var reg 1 8 alusrcbimm $end
$var reg 5 ? destreg [4:0] $end
$var reg 1 6 dobranch $end
$var reg 1 5 dojal $end
$var reg 1 4 dojr $end
$var reg 1 3 dojump $end
$var reg 1 2 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 0 regwrite $end
$var reg 1 / shift16left $end
$upscope $end
$scope module dp $end
$var wire 3 @ alucontrol [2:0] $end
$var wire 1 8 alusrcbimm $end
$var wire 1 ) clk $end
$var wire 5 A destreg [4:0] $end
$var wire 1 6 dobranch $end
$var wire 1 5 dojal $end
$var wire 1 4 dojr $end
$var wire 32 B instr [31:0] $end
$var wire 1 3 jump $end
$var wire 1 2 memtoreg $end
$var wire 32 C pcjal [31:0] $end
$var wire 32 D readdata [31:0] $end
$var wire 1 0 regwrite $end
$var wire 1 , reset $end
$var wire 1 / shift16left $end
$var wire 32 E writedata [31:0] $end
$var wire 1 - zero $end
$var wire 32 F srcbimm [31:0] $end
$var wire 32 G srcb [31:0] $end
$var wire 32 H srca [31:0] $end
$var wire 32 I signimm [31:0] $end
$var wire 32 J result [31:0] $end
$var wire 32 K pc [31:0] $end
$var wire 32 L aluout [31:0] $end
$scope module alu $end
$var wire 3 M alucontrol [2:0] $end
$var wire 32 N b [31:0] $end
$var wire 32 O result [31:0] $end
$var wire 1 - zero $end
$var wire 32 P a [31:0] $end
$var reg 32 Q RES [31:0] $end
$var reg 64 R hilo [63:0] $end
$upscope $end
$scope module gpr $end
$var wire 1 ) clk $end
$var wire 1 5 dojal $end
$var wire 32 S pcjal [31:0] $end
$var wire 5 T ra1 [4:0] $end
$var wire 5 U ra2 [4:0] $end
$var wire 5 V wa3 [4:0] $end
$var wire 32 W wd3 [31:0] $end
$var wire 1 0 we3 $end
$var wire 32 X rd2 [31:0] $end
$var wire 32 Y rd1 [31:0] $end
$var wire 32 Z pc [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ) clk $end
$var wire 1 6 dobranch $end
$var wire 1 4 dojr $end
$var wire 1 3 dojump $end
$var wire 26 [ jumptarget [25:0] $end
$var wire 32 \ pcjr [31:0] $end
$var wire 32 ] progcounter [31:0] $end
$var wire 1 , reset $end
$var wire 32 ^ nextpc [31:0] $end
$var wire 32 _ incpc [31:0] $end
$var wire 32 ` branchpc [31:0] $end
$var wire 32 a branchoffset [31:0] $end
$var reg 32 b pc [31:0] $end
$scope module pcbranch $end
$var wire 32 c b [31:0] $end
$var wire 1 d cin $end
$var wire 32 e y [31:0] $end
$var wire 1 f cout $end
$var wire 32 g a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 h a [31:0] $end
$var wire 32 i b [31:0] $end
$var wire 1 j cin $end
$var wire 32 k y [31:0] $end
$var wire 1 l cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 m a [15:0] $end
$var wire 32 n y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$scope module mips $end
$scope module decoder $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module SanitizerMain $end
$scope module proc $end
$scope module mips $end
$scope module dp $end
$scope module alu $end
$upscope $end
$scope module gpr $end
$upscope $end
$scope module pcenv $end
$scope module pcbranch $end
$upscope $end
$scope module pcinc $end
$upscope $end
$upscope $end
$scope module se $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx n
bx m
xl
bx k
0j
b100 i
bx h
bx g
xf
bx e
0d
bx00 c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
x8
bx 7
x6
x5
x4
x3
x2
bx 1
x0
x/
bx .
x-
z,
bx +
bx *
z)
x(
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#1
